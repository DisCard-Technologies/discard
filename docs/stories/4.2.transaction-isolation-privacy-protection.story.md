# Story 4.2: Transaction Isolation & Privacy Protection

**Status:** Ready for development  
**Priority:** High  
**Epic:** Privacy & Security Features (Epic 4)  
**Dependencies:** Story 4.1 (Secure Card Deletion & Data Destruction)  
**Estimated Effort:** 18-22 hours  

## Story

**As a** user,  
**I want** complete assurance that my transactions across different disposable cards cannot be correlated,  
**so that** I can maintain true financial privacy and prevent comprehensive spending profiling.

## Problem Statement

Users require absolute transaction isolation to prevent correlation across different disposable cards, ensuring true financial privacy. Current systems often create subtle data linkages through user IDs, timestamps, IP addresses, or shared metadata that can be used to build comprehensive spending profiles. The challenge is implementing complete isolation while maintaining operational functionality, compliance requirements, and system performance, ensuring that no internal systems, employees, or external parties can correlate transactions across different cards.

## Solution Overview

Implement comprehensive transaction isolation architecture using cryptographic context separation, database-level privacy controls, and privacy-preserving analytics. The system will extend existing row-level security (RLS) patterns from previous stories, implement zero-knowledge audit trails, create isolated data access patterns, and establish privacy verification systems that ensure complete transaction isolation while maintaining regulatory compliance and operational effectiveness.

## Acceptance Criteria

### AC 4.2.1: Database Architecture with Strict Data Isolation
**As a system architect, I want database-level isolation preventing correlation of transactions across different disposable cards**

- [ ] Implement enhanced row-level security policies preventing cross-card data access at database level with <100ms query performance
- [ ] Create cryptographic card context isolation using unique context hashes per card without user linkage, ensuring <50ms context verification
- [ ] Add database constraints preventing JOIN operations across card contexts or user correlation with zero performance degradation
- [ ] Implement temporal isolation preventing timing-based correlation through query patterns, maintaining <200ms API response times
- [ ] Create data access audit trail tracking all queries to detect isolation violations with <10ms logging overhead
- [ ] Add automated isolation verification tests running continuously in production with <5-minute violation detection SLA
- [ ] Implement database view restrictions limiting system access to single-card contexts only, ensuring 100% query isolation coverage

### AC 4.2.2: User Activity Tracking with Context Separation
**As a privacy engineer, I want separate activity contexts for each card without linking them to comprehensive user profiles**

- [ ] Create card-specific activity tracking systems with isolated context storage, achieving <30ms session lookup performance
- [ ] Implement session isolation preventing cross-card session correlation or user tracking with 99.9% isolation accuracy
- [ ] Add IP address anonymization and rotation preventing location-based correlation, rotating every <15 minutes
- [ ] Create separate authentication contexts for each card access without user profiling, maintaining <100ms auth verification
- [ ] Implement privacy-preserving logging that records events without cross-card linkage, ensuring <5ms log processing overhead
- [ ] Add activity pattern randomization preventing behavioral analysis across cards with configurable noise levels (10-30%)
- [ ] Create context switching mechanisms ensuring clean isolation boundaries with <1ms switching latency

### AC 4.2.3: Internal Access Controls & Employee Restrictions
**As a compliance officer, I want internal access controls preventing employees from accessing cross-card data or building user spending profiles**

- [ ] Implement role-based access control (RBAC) limiting employee access to single-card contexts with <2-second permission verification
- [ ] Create database access restrictions preventing cross-card queries by internal tools, blocking 100% of unauthorized join attempts
- [ ] Add audit trail monitoring for all internal data access attempts with violation alerts triggered within <30 seconds
- [ ] Implement privacy training requirements and certification for employees accessing card data with quarterly recertification
- [ ] Create data access justification system requiring business reasons for card data access, processing requests within <1 hour
- [ ] Add automated detection of suspicious internal access patterns or correlation attempts with <10-minute alert response time
- [ ] Implement "need-to-know" data access policies with automated enforcement achieving 99.99% compliance rate

### AC 4.2.4: Third-Party Integration Privacy Limits
**As a security architect, I want integration limits ensuring external services cannot correlate transactions or access comprehensive user data**

- [ ] Create API rate limiting and data access restrictions for external service integrations: Marqeta (max 100 req/min per card), fraud detection services (max 50 req/min), analytics partners (max 10 req/min)
- [ ] Implement data sharing agreements limiting third-party access to single-card contexts only: Marqeta receives only card-specific transaction data, fraud services get transaction patterns without user correlation, compliance services access single-card audit trails
- [ ] Add external API audit trails tracking all data shared with third-party services with <100ms logging and 30-day retention
- [ ] Create anonymization layers for external reporting preventing user or cross-card identification: hash card IDs before sharing, remove timestamps precision beyond day-level, strip IP addresses and location data
- [ ] Implement webhook payload filtering ensuring only necessary data is shared externally: Marqeta webhooks contain only transaction status updates, fraud alerts include transaction details without user context, compliance reports use anonymized identifiers
- [ ] Add third-party integration monitoring detecting correlation attempts or data misuse with <5-minute violation detection and automatic API throttling
- [ ] Create external service certification requirements for privacy-preserving data handling: mandatory SOC 2 Type II compliance, annual privacy audits, signed data isolation agreements, zero-knowledge architecture verification

### AC 4.2.5: Audit Verification & Continuous Isolation Monitoring  
**As a privacy officer, I want regular confirmation that transaction isolation is maintained and no correlation systems exist**

- [ ] Create automated isolation testing suite running continuous verification checks every 15 minutes with 99.9% uptime SLA
- [ ] Implement correlation detection algorithms monitoring for potential privacy violations with <1% false positive rate and <0.1% false negative rate
- [ ] Add privacy metrics dashboard showing isolation effectiveness and violation attempts with real-time updates (<10 second refresh)
- [ ] Create quarterly privacy audit reports demonstrating isolation maintenance with 100% compliance verification and <48 hour generation time
- [ ] Implement red team exercises testing isolation boundaries and correlation resistance with monthly penetration attempts and <24 hour remediation SLA
- [ ] Add privacy violation alerting system with immediate response protocols triggering within <60 seconds and automated containment within <5 minutes
- [ ] Create isolation verification API for third-party privacy assessments with <200ms response time and 99.99% availability

### AC 4.2.6: Privacy-Preserving Analytics & Reporting
**As a product manager, I want aggregate statistics without compromising individual user privacy or transaction correlation**

- [ ] Implement differential privacy algorithms for aggregate analytics preventing user identification with epsilon=1.0 privacy budget and <500ms query processing
- [ ] Create k-anonymity reporting ensuring no individual transactions can be identified with minimum k=5 grouping and 99.99% anonymity guarantee
- [ ] Add noise injection systems for statistical reporting preventing correlation analysis using Laplace mechanism with calibrated noise levels (Â±10-20% variance)
- [ ] Implement aggregate-only reporting APIs with privacy-preserving query restrictions, limiting to statistical summaries only with <300ms response time
- [ ] Create privacy-safe business intelligence dashboards with isolation verification, updating every 1 hour with epsilon budget tracking
- [ ] Add statistical disclosure control preventing inference attacks on aggregate data with automated query blocking for risky patterns
- [ ] Implement privacy budget management for all analytical queries and reports with daily epsilon allocation (max 10.0) and automatic reset

### AC 4.2.7: Compliance Reporting with Privacy Maintenance
**As a compliance officer, I want regulatory reporting satisfying requirements while maintaining transaction isolation and user privacy protection**

- [ ] Create compliance reporting system generating required data without cross-card correlation, processing reports within <2 hours with zero data linkage
- [ ] Implement regulatory audit trails maintaining isolation while satisfying reporting requirements with 7-year retention and <50ms query performance
- [ ] Add anonymized compliance metrics for regulatory submissions without user identification using cryptographic hashing with salt rotation every 90 days
- [ ] Create privacy-compliant AML/KYC monitoring with card-specific context isolation, processing alerts within <15 minutes while maintaining 100% isolation
- [ ] Implement GDPR-compliant data processing with verifiable isolation maintenance, ensuring Article 25 compliance with automated verification every 24 hours
- [ ] Add regulatory reporting verification ensuring privacy preservation in all submissions with 99.99% accuracy and <1 hour validation time
- [ ] Create compliance dashboard showing isolation maintenance during regulatory processes with real-time status updates and monthly compliance score calculation

## Tasks/Subtasks

### Phase 1: Database Isolation Infrastructure (8-10 hours)
1. **Enhanced Database Schema & RLS Policies** (4-5 hours)
   - Create migration 015 enhancing RLS policies for complete isolation  
   - Implement cryptographic context separation extending patterns from Story 4.1
   - Add database constraints preventing cross-context queries and correlation
   - Create temporal isolation mechanisms preventing timing-based correlation

2. **Isolation Verification System** (2-3 hours)
   - Implement automated isolation testing suite with continuous monitoring
   - Create correlation detection algorithms for privacy violation monitoring
   - Add privacy metrics collection and dashboard integration

3. **Database Access Audit System** (2 hours)  
   - Extend audit infrastructure from Story 4.1 for database access monitoring
   - Implement query pattern analysis detecting isolation violations
   - Create violation alerting system with immediate response protocols

### Phase 2: Application-Level Privacy Controls (6-7 hours)
4. **Context Isolation Service** (3-4 hours)
   - Create TransactionIsolationService extending existing privacy patterns
   - Implement card context switching with clean isolation boundaries
   - Add session isolation preventing cross-card correlation

5. **Internal Access Control System** (2-3 hours)
   - Implement RBAC system limiting employee access to single-card contexts
   - Create access justification system with business reason requirements
   - Add suspicious access pattern detection with automated alerts

6. **Third-Party Integration Controls** (1 hour)
   - Extend external API patterns with privacy-preserving data sharing limits
   - Implement webhook payload filtering and anonymization layers
   - Create third-party integration monitoring and certification requirements

### Phase 3: Privacy-Preserving Analytics (3-4 hours)
7. **Differential Privacy Analytics** (2-3 hours)
   - Implement differential privacy algorithms for aggregate reporting  
   - Create k-anonymity reporting with statistical disclosure controls
   - Add noise injection systems preventing correlation analysis

8. **Compliance Reporting System** (1 hour)
   - Extend compliance infrastructure from Story 4.1 for privacy-preserving reports
   - Create anonymized regulatory metrics without cross-card correlation
   - Implement privacy-compliant AML/KYC monitoring

### Phase 4: Testing & Verification (2-3 hours)
9. **Comprehensive Testing Suite** (1-2 hours)
   - Unit tests for isolation services and privacy controls
   - Integration tests for complete privacy verification workflows  
   - Red team testing for correlation resistance

10. **Documentation & Deployment** (1 hour)
    - API documentation for isolation verification endpoints
    - Privacy policy updates reflecting enhanced isolation
    - Production deployment with monitoring integration

## Dev Notes

### Technical Context from Previous Stories

#### Existing Privacy Isolation Infrastructure (from Stories 3.4 & 4.1)
Story 4.1 established comprehensive cryptographic deletion with KMS integration:
```typescript
// Established privacy isolation pattern from Story 4.1
async function setCardContext(cardId: string) {
  const cardContext = await generateCardContext(cardId);
  await supabase.rpc('set_app_context', { 
    context_value: cardContext 
  });
}

// Cryptographic context generation from Story 3.4
async function generateCardContext(cardId: string): Promise<string> {
  const contextSeed = await kms.encrypt({
    KeyId: cardContextKeyId,
    Plaintext: Buffer.from(cardId)
  });
  return crypto.createHash('sha256').update(contextSeed.CiphertextBlob).digest('hex');
}
```
[Source: architecture/data-models.md#card-model]

#### Row-Level Security Foundation (from Stories 3.1-4.1)
Well-established RLS patterns for privacy isolation:
```sql
-- Existing RLS policies from previous stories
CREATE POLICY card_isolation ON cards
    FOR ALL
    USING (card_context_hash = current_setting('app.card_context', true));

CREATE POLICY payment_isolation ON payment_transactions
    FOR ALL  
    USING (card_context_hash = current_setting('app.card_context', true));
```
[Source: architecture/database-schema.md#privacy-preserving-database-design]

#### Audit Infrastructure (from Story 4.1)
Comprehensive audit system for compliance without privacy violations:
```typescript
// Privacy-preserving audit pattern from Story 4.1
interface IsolationAuditEvent {
  eventType: 'data_access' | 'context_switch' | 'correlation_attempt';
  contextHash: string; // No direct user/card reference
  accessPattern: string; // Query signature without data
  timestamp: Date;
  violationDetected: boolean;
}
```

### Architecture Context for Transaction Isolation

#### Enhanced Data Models [Source: architecture/data-models.md#card-model]
```typescript
interface EnhancedCard extends Card {
  isolationContext: string; // Cryptographic isolation boundary
  correlationResistanceHash: string; // Anti-correlation verification
  contextSwitchAudit: {
    lastAccessed: Date;
    accessPattern: string;
    isolationVerified: boolean;
  };
}

interface TransactionIsolationMetrics {
  isolationId: string; // UUID v4
  cardContextHash: string; // Privacy-isolated reference  
  isolationVerified: boolean;
  correlationAttempts: number;
  lastVerificationTime: Date;
  privacyViolationDetected: boolean;
}
```

#### Database Schema Enhancements [Source: architecture/database-schema.md#privacy-preserving-database-design]
```sql
-- Enhanced isolation with correlation resistance
ALTER TABLE cards ADD COLUMN isolation_context_hash TEXT NOT NULL DEFAULT gen_random_uuid();
ALTER TABLE cards ADD COLUMN correlation_resistance_hash TEXT;
ALTER TABLE cards ADD COLUMN last_context_verification TIMESTAMP WITH TIME ZONE DEFAULT NOW();

-- Transaction isolation verification table
CREATE TABLE transaction_isolation_metrics (
    isolation_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    card_context_hash TEXT NOT NULL,
    isolation_verified BOOLEAN NOT NULL DEFAULT false,
    correlation_attempts INTEGER DEFAULT 0,
    last_verification_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    privacy_violation_detected BOOLEAN DEFAULT false
);

-- Enhanced audit table for isolation monitoring
ALTER TABLE compliance_audit ADD COLUMN isolation_event_data JSONB;
ALTER TABLE compliance_audit ADD COLUMN correlation_detection_result BOOLEAN;

-- Advanced RLS policies preventing correlation
CREATE POLICY enhanced_card_isolation ON cards
    FOR ALL
    USING (
        card_context_hash = current_setting('app.card_context', true) AND
        isolation_context_hash = current_setting('app.isolation_context', true)
    );

-- Cross-table correlation prevention
CREATE POLICY prevent_cross_table_correlation ON payment_transactions
    FOR ALL
    USING (
        card_context_hash = current_setting('app.card_context', true) AND
        NOT EXISTS (
            SELECT 1 FROM cards c 
            WHERE c.card_context_hash != payment_transactions.card_context_hash
        )
    );
```

#### API Specifications for Isolation [Source: architecture/api-specification.md#paths]
```typescript
// Isolation verification endpoint design
interface IsolationVerificationResponse {
  isolated: boolean;
  contextHash: string; // Privacy-isolated reference
  verificationProof: string; // Cryptographic isolation proof
  correlationAttempts: number;
  lastVerified: string; // ISO timestamp
  privacyViolations: boolean;
}

// Privacy-preserving analytics endpoint
interface PrivateAnalyticsRequest {
  metricType: 'aggregate_spend' | 'transaction_count' | 'merchant_categories';
  timeRange: { start: string; end: string };
  privacyBudget: number; // Differential privacy epsilon
  k_anonymity_threshold: number; // Minimum group size
}
```

#### Component Specifications [Source: architecture/components.md#privacy-protection-service]
The Privacy Protection Service will be extended with:
- Transaction isolation verification engine
- Cross-card correlation detection algorithms  
- Privacy-preserving analytics with differential privacy
- Internal access control and audit systems
- Third-party integration privacy limits

#### File Structure for This Story

#### Backend Services
- `/apps/api/src/services/privacy/transaction-isolation.service.ts` - Core isolation management and verification
- `/apps/api/src/services/privacy/correlation-detection.service.ts` - Anti-correlation monitoring and detection
- `/apps/api/src/services/privacy/privacy-analytics.service.ts` - Differential privacy analytics engine
- `/apps/api/src/services/compliance/isolation-audit.service.ts` - Isolation-specific compliance auditing
- `/apps/api/src/middleware/isolation.middleware.ts` - Request-level context isolation enforcement

#### API Controllers
- `/apps/api/src/controllers/privacy/isolation.controller.ts` - Isolation verification and monitoring endpoints
- `/apps/api/src/controllers/analytics/privacy-analytics.controller.ts` - Privacy-preserving analytics endpoints
- `/apps/api/src/controllers/compliance/isolation-compliance.controller.ts` - Compliance reporting with isolation

#### Mobile Components
- `/apps/mobile/src/components/privacy/IsolationStatusIndicator.tsx` - Real-time isolation verification display
- `/apps/mobile/src/components/privacy/PrivacyDashboard.tsx` - User privacy metrics and verification
- `/apps/mobile/src/screens/privacy/TransactionIsolationScreen.tsx` - Comprehensive isolation management interface

#### Database Migration
- `/database/migrations/015_transaction_isolation_enhancement.sql` - Enhanced isolation tables and policies

### Technical Implementation Details

#### Transaction Isolation Architecture
```typescript
interface IsolationContext {
  contextId: string; // Unique per card access session
  cardContextHash: string; // Card-specific isolation boundary
  sessionBoundary: string; // Temporal isolation marker
  correlationResistance: {
    ipObfuscation: boolean;
    timingRandomization: boolean;
    behaviorMasking: boolean;
  };
}

// Context isolation enforcement
async function enforceTransactionIsolation(cardId: string): Promise<void> {
  const isolationContext = await generateIsolationContext(cardId);
  
  // Set database-level isolation
  await supabase.rpc('set_app_context', { 
    context_value: isolationContext.cardContextHash 
  });
  await supabase.rpc('set_isolation_context', { 
    context_value: isolationContext.contextId 
  });
  
  // Verify isolation boundaries
  const isolationVerified = await verifyIsolationBoundaries(isolationContext);
  if (!isolationVerified) {
    throw new Error('Isolation verification failed');
  }
}
```

#### Correlation Detection Algorithm
```typescript
interface CorrelationDetection {
  detectCrossCardCorrelation(): Promise<CorrelationResult>;
  monitorAccessPatterns(): Promise<AccessPattern[]>;
  identifyPrivacyViolations(): Promise<PrivacyViolation[]>;
}

async function detectPotentialCorrelation(
  accessPatterns: AccessPattern[]
): Promise<CorrelationRisk> {
  const temporalCorrelation = analyzeTemporalPatterns(accessPatterns);
  const spatialCorrelation = analyzeSpatialPatterns(accessPatterns);
  const behavioralCorrelation = analyzeBehavioralPatterns(accessPatterns);
  
  return {
    riskLevel: calculateCorrelationRisk([
      temporalCorrelation,
      spatialCorrelation, 
      behavioralCorrelation
    ]),
    violationDetected: temporalCorrelation.violation || 
                      spatialCorrelation.violation || 
                      behavioralCorrelation.violation,
    mitigationRequired: true
  };
}
```

#### Differential Privacy Implementation
```typescript
interface PrivacyPreservingAnalytics {
  epsilon: number; // Privacy budget parameter
  delta: number; // Privacy failure probability
  sensitivity: number; // Query sensitivity
}

async function generatePrivateAnalytics(
  query: AnalyticsQuery,
  privacyParams: PrivacyPreservingAnalytics
): Promise<PrivateAnalyticsResult> {
  // Add calibrated noise for differential privacy
  const trueResult = await executeAnalyticsQuery(query);
  const noise = generateLaplaceNoise(privacyParams.epsilon, privacyParams.sensitivity);
  
  const privateResult = {
    value: trueResult.value + noise,
    confidenceInterval: calculateConfidenceInterval(noise, privacyParams),
    privacyBudgetConsumed: privacyParams.epsilon,
    k_anonymity_satisfied: await verifyKAnonymity(query, 5) // Minimum group size
  };
  
  return privateResult;
}
```

### Integration Points

#### Story 4.1 Integration (Secure Card Deletion & Data Destruction)
- **Deletion Isolation**: Ensure deleted cards cannot be correlated with active cards through deletion timing
- **Audit Trail Integration**: Extend deletion audit system for isolation verification during deletion
- **Context Cleanup**: Proper isolation context cleanup during cryptographic deletion process
- **Migration Dependency**: This story's migration (015) extends RLS policies from migration 014

#### Story 3.4 Integration (Privacy-Preserving Transaction History)  
- **History Isolation**: Maintain transaction history isolation preventing cross-card correlation
- **Privacy Retention**: Extend retention policies with isolation-aware data management
- **KMS Integration**: Use established KMS patterns for isolation context encryption
- **Audit Enhancement**: Extend existing audit patterns for isolation event tracking

#### Epic 5 Preparation (Advanced Features)
- **Analytics Foundation**: Privacy-preserving analytics patterns for advanced features
- **Compliance Integration**: Isolation-aware compliance monitoring for advanced regulatory features
- **Performance Monitoring**: Isolation verification patterns for system performance features

## Testing Strategy

### Testing Standards (from Architecture) [Source: architecture/testing-strategy.md]
- Test files location: `__tests__/` directories adjacent to source files
- Unit tests: Jest with 80% coverage requirement  
- Integration tests: Supertest for API endpoints with isolation verification
- Mobile tests: Expo Testing (Detox) for privacy UI scenarios
- Use existing test utilities from `/packages/shared/test-utils`

### Unit Tests
- Transaction isolation service with context verification - `/apps/api/src/services/privacy/__tests__/transaction-isolation.service.test.ts`
- Correlation detection algorithms with privacy violation testing - `/apps/api/src/services/privacy/__tests__/correlation-detection.service.test.ts`  
- Privacy-preserving analytics with differential privacy verification - `/apps/api/src/services/privacy/__tests__/privacy-analytics.service.test.ts`
- Isolation audit service with compliance verification - `/apps/api/src/services/compliance/__tests__/isolation-audit.service.test.ts`

### Integration Tests
- Complete isolation workflow from card creation to transaction processing - `/apps/api/src/__tests__/integration/transaction-isolation.test.ts`
- Cross-card correlation prevention with attack simulation - `/apps/api/src/__tests__/integration/correlation-prevention.test.ts`
- Privacy-preserving analytics with aggregate data verification - `/apps/api/src/__tests__/integration/privacy-analytics.test.ts`
- Internal access control with role-based restriction testing - `/apps/api/src/__tests__/integration/access-control.test.ts`

### Mobile E2E Tests (Detox)  
- Privacy dashboard with isolation status verification - `/apps/mobile/e2e/privacy-dashboard.e2e.js`
- Transaction isolation indicator with real-time updates - `/apps/mobile/e2e/isolation-verification.e2e.js`
- Cross-card privacy verification with correlation resistance - `/apps/mobile/e2e/privacy-protection.e2e.js`

### Security Tests (Red Team)
- Cross-card correlation attack simulation - dedicated security test suite
- Database isolation penetration testing - attempt unauthorized cross-context queries
- Privacy violation detection effectiveness - test correlation detection algorithms
- Internal access control bypass attempts - test employee access restrictions

### Privacy Tests
- Differential privacy budget verification - ensure privacy guarantees are maintained
- K-anonymity verification for aggregate reporting - test group size requirements
- Correlation resistance testing - verify anti-correlation measures effectiveness
- Privacy audit trail integrity - ensure audit logs maintain privacy while recording events

### Performance Tests
- Isolation verification performance under high load - ensure <100ms verification time
- Privacy-preserving analytics performance with large datasets - test differential privacy computation
- RLS policy performance with complex isolation rules - ensure database query performance
- Context switching performance for rapid card access - test isolation boundary enforcement speed

## Definition of Done

- [ ] All acceptance criteria implemented and tested with privacy verification
- [ ] Enhanced RLS policies prevent all forms of cross-card correlation
- [ ] Privacy-preserving analytics demonstrated with differential privacy guarantees
- [ ] Internal access controls prevent employee correlation attempts
- [ ] Third-party integration limits verified with privacy compliance testing
- [ ] Continuous isolation monitoring operational with violation detection
- [ ] Compliance reporting maintains privacy while satisfying regulatory requirements
- [ ] Mobile interface provides clear privacy verification and isolation status
- [ ] Performance benchmarks met (<100ms isolation verification, <200ms analytics queries)
- [ ] Security review completed with red team correlation attack testing
- [ ] Privacy audit completed with third-party verification of isolation effectiveness
- [ ] Production deployment successful with privacy monitoring active

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-09 | 1.0 | Initial story creation for Epic 4.2 based on PRD requirements and architecture analysis | AI Assistant (Scrum Master) |
| 2025-08-09 | 1.1 | Enhanced with specific performance benchmarks and concrete third-party integration examples per Product Owner validation feedback | AI Assistant (Product Owner) |