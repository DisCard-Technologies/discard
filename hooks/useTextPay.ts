/**
 * DisCard 2035 - useTextPay Hook
 *
 * React hook for TextPay SMS invitations to non-users.
 * Handles creating and sending invitations with pending transfers.
 */

import { useState, useCallback } from "react";
import { useMutation, useAction, useQuery } from "convex/react";
import { api } from "@/convex/_generated/api";
import { Id } from "@/convex/_generated/dataModel";

// ============================================================================
// Types
// ============================================================================

export interface TextPayInviteParams {
  /** Recipient phone number (E.164 format) */
  recipientPhone: string;
  /** Amount in base units (not cents) */
  amount: number;
  /** Token symbol (e.g., "USDC") */
  token: string;
  /** Token mint address */
  mint: string;
  /** Token decimals */
  decimals: number;
  /** Optional custom message */
  message?: string;
  /** Sender's Turnkey sub-organization ID (for auto-release) */
  senderSubOrgId: string;
  /** Sender's wallet address */
  senderWalletAddress: string;
}

export interface TextPayResult {
  /** Invitation ID */
  invitationId: Id<"invitations">;
  /** Invite code for claiming */
  inviteCode: string;
  /** Whether SMS was sent successfully */
  smsSent: boolean;
  /** Error message if SMS failed */
  smsError?: string;
}

export interface UseTextPayReturn {
  /** Create and send a TextPay invitation */
  sendInvite: (params: TextPayInviteParams) => Promise<TextPayResult>;
  /** Whether an operation is in progress */
  isLoading: boolean;
  /** Error message if any */
  error: string | null;
  /** Clear error state */
  clearError: () => void;
}

// ============================================================================
// Hook Implementation
// ============================================================================

export function useTextPay(): UseTextPayReturn {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Convex mutations and actions
  const createInvitation = useMutation(api.transfers.invitations.create);
  const sendInvitationSMS = useAction(api.transfers.invitations.send);

  const sendInvite = useCallback(
    async (params: TextPayInviteParams): Promise<TextPayResult> => {
      setIsLoading(true);
      setError(null);

      try {
        // 1. Create the invitation record
        const invitationId = await createInvitation({
          recipientPhone: params.recipientPhone,
          message: params.message,
          pendingAmount: params.amount,
          pendingToken: params.token,
          pendingMint: params.mint,
          pendingDecimals: params.decimals,
          senderSubOrgId: params.senderSubOrgId,
          senderWalletAddress: params.senderWalletAddress,
        });

        // 2. Send the SMS
        let smsSent = false;
        let smsError: string | undefined;

        try {
          const smsResult = await sendInvitationSMS({ invitationId });
          smsSent = smsResult.success;
        } catch (err) {
          smsError = err instanceof Error ? err.message : "SMS delivery failed";
          console.error("[TextPay] SMS send failed:", err);
        }

        // 3. Get the invite code from the created invitation
        // Note: The invite code is generated by the create mutation
        // We return success even if SMS failed - the invitation exists
        return {
          invitationId,
          inviteCode: "", // Will be populated by the caller if needed
          smsSent,
          smsError,
        };
      } catch (err) {
        const errorMessage =
          err instanceof Error ? err.message : "Failed to create invitation";
        setError(errorMessage);
        throw new Error(errorMessage);
      } finally {
        setIsLoading(false);
      }
    },
    [createInvitation, sendInvitationSMS]
  );

  const clearError = useCallback(() => {
    setError(null);
  }, []);

  return {
    sendInvite,
    isLoading,
    error,
    clearError,
  };
}

export default useTextPay;
